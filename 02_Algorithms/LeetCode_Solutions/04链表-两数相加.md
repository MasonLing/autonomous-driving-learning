# 两数相加：链表表示的数字相加

## 问题描述大白话

想象一下，有两个数字，比如 `342` 和 `465`，但它们不是正常写法，而是**倒着写**在链表里：
- `342` 倒着写就是 `2 → 4 → 3`
- `465` 倒着写就是 `5 → 6 → 4`

我们的任务就是把这两个"倒着写的数字"相加，得到的结果也**用同样的倒着写的方式**放在链表里。

比如：`342 + 465 = 807`，倒着写就是 `7 → 0 → 8`

---

## 链表基础知识（零基础必看）

### 什么是链表？
链表就像**一列小火车**，每个车厢（节点）都装着：
- **货物**（节点的值 `val`）
- **连接钩**（指向下一个车厢的指针 `next`）

```cpp
struct ListNode {
    int val;           // 这个节点存储的数字（0-9）
    ListNode* next;    // 指向下一个节点的"箭头"
    
    // 三种造车厢的方法：
    ListNode() : val(0), next(nullptr) {}                    // 造一个空车厢
    ListNode(int x) : val(x), next(nullptr) {}               // 造一个装指定货物的车厢
    ListNode(int x, ListNode* next) : val(x), next(next) {}  // 造一个车厢并连接好
};
```

### 链表 vs 数组
| 特点 | 数组 | 链表 |
|------|------|------|
| **存储方式** | 连续内存 | 分散内存 |
| **访问速度** | 快（直接跳转） | 慢（要一个一个找） |
| **插入删除** | 慢（要移动其他元素） | 快（改个指针就行） |
| **本题优势** | 数字是正序存储 | 数字是逆序存储，方便计算 |

---

## 代码逐行详解

### 1. 准备工作
```cpp
ListNode* dummy = new ListNode(0);  // 造一个"假车头"，方便挂接真车厢
ListNode* curr = dummy;             // 当前正在处理的车厢
int carry = 0;                      // 进位，比如 5+7=12，进位就是1
```

**为什么用假车头？**
- 如果没有假车头，第一个车厢要特殊处理，很麻烦
- 有了假车头，所有车厢都一样处理，最后返回 `dummy->next` 就行

### 2. 核心计算循环
```cpp
while (l1 != nullptr || l2 != nullptr || carry != 0) {
```
**循环条件解释：**
- `l1 != nullptr`：第一个数字还有位数没算完
- `l2 != nullptr`：第二个数字还有位数没算完  
- `carry != 0`：还有进位要处理（比如 999+1=1000，最后多出一位）

```cpp
int val1 = (l1 != nullptr) ? l1->val : 0;
int val2 = (l2 != nullptr) ? l2->val : 0;
```
**取值逻辑：**
- 如果链表还有节点，取节点的值
- 如果链表已经空了，就当它是0（比如 123 + 45，相当于 123 + 045）

```cpp
int sum = val1 + val2 + carry;      // 当前位的总和
int current = sum % 10;             // 当前位的结果（取个位数）
carry = sum / 10;                   // 进位（取十位数）
```

**计算示例：**
```
7 + 8 + 进位1 = 16
current = 16 % 10 = 6  （这一位写6）
carry = 16 / 10 = 1    （进1到高位）
```

```cpp
curr->next = new ListNode(current);  // 造新车厢存放结果
curr = curr->next;                   // 移动到下一个位置

// 移动输入链表的指针
if (l1 != nullptr) l1 = l1->next;
if (l2 != nullptr) l2 = l2->next;
```

### 3. 返回结果
```cpp
return dummy->next;  // 跳过假车头，返回真正的第一个车厢
```

---

## 完整执行示例

### 例子：342 + 465 = 807
输入：
- l1: 2 → 4 → 3  （表示342）
- l2: 5 → 6 → 4  （表示465）

**执行过程：**

| 步骤 | l1值 | l2值 | 进位 | 总和 | 当前位 | 新进位 | 结果链表 |
|------|------|------|------|------|--------|--------|----------|
| 1 | 2 | 5 | 0 | 7 | 7 | 0 | 7 |
| 2 | 4 | 6 | 0 | 10 | 0 | 1 | 7→0 |
| 3 | 3 | 4 | 1 | 8 | 8 | 0 | 7→0→8 |

输出：7 → 0 → 8 （表示807）

---

## 关键知识点总结

### 1. 链表操作技巧
```cpp
// 遍历链表
ListNode* curr = head;
while (curr != nullptr) {
    // 处理 curr->val
    curr = curr->next;
}

// 创建新节点
new ListNode(值);
new ListNode(值, 下一个节点);
```

### 2. 进位处理
- **加法规则**：从低位到高位逐位相加
- **进位产生**：当和 ≥10 时产生进位
- **进位使用**：下一位计算时要加上进位

### 3. 边界情况处理
- **链表长度不同**：短的数字补0
- **最后有进位**：要多创建一个节点
- **空链表**：当作0处理

### 4. 虚拟头节点技巧
```cpp
ListNode* dummy = new ListNode(0);  // 创建假头
// ... 构建链表 ...
return dummy->next;                 // 返回真头
```
**好处**：避免对第一个节点的特殊处理

---

## 时间复杂度分析

### 时间复杂度：O(max(m,n))
- m、n 分别是两个链表的长度
- 需要遍历较长的那个链表
- 每个节点只处理一次

### 空间复杂度：O(max(m,n))
- 结果链表的长度最多为 max(m,n)+1
- 除了结果链表，只用了常数空间

---

## 面试常见问题与回答

### Q1: 为什么要用逆序存储？正序存储可以吗？
**回答**：逆序存储让计算变得简单，因为加法是从个位开始的。如果正序存储，要么先把链表反转，要么用递归从后往前计算，都会更复杂。

### Q2: 如果数字特别大（比如1000位），这个算法还适用吗？
**回答**：适用。链表的好处就是可以处理任意大的数字，不像int或long有位数限制。这是处理大数加法的常用方法。

### Q3: 能不用虚拟头节点吗？
**回答**：可以，但代码会变复杂。需要单独处理第一个节点，判断该用l1的值、l2的值还是两者的和。

### Q4: 如果输入链表中有负数怎么办？
**回答**：题目说是非负整数，所以不考虑负数。如果有负数，需要先判断符号，然后做减法，复杂很多。

### Q5: 这个算法能处理多个数字相加吗？
**回答**：可以扩展。可以维护一个进位，然后依次加每个数字的对应位，原理类似。

### Q6: 如果链表中有环（循环）会怎样？
**回答**：这个算法假设输入是合法链表。如果有环，会陷入死循环。在实际应用中应该先检查链表是否有环。

### Q7: 为什么选择链表而不是数组？
**回答**：链表可以动态增长，适合处理位数不确定的大数。数组需要预先分配空间，可能浪费或者不够用。

### Q8: 如何优化这个算法？
**回答**：几个优化方向：
1. 如果某个链表先结束，可以直接把另一个链表的剩余部分接上（但要处理进位）
2. 对于特别长的数字，可以用并行计算
3. 如果内存紧张，可以尝试复用输入链表的节点

### Q9: 这个算法在实际中有什么应用？
**回答**：大数计算（密码学、科学计算）、高精度数学库、编译器中的常数处理等。

### Q10: 如果要把结果正序存储怎么办？
**回答**：两种方法：
1. 先逆序计算，再把结果逆序
2. 用递归，从最后一位开始计算
3. 用栈来辅助计算

---

## 扩展思考

### 变体1：数字正序存储
如果链表是正序存储（比如 3→4→2 表示342），计算会更复杂，需要处理位数对齐和从高位到低位的计算顺序。

### 变体2：三个数相加
思路类似，同时维护三个指针，处理三个数字的相加。

### 变体3：加减乘除全套
可以在链表基础上实现完整的大数四则运算库。

---

## 总结

这个算法巧妙利用了链表的特性和加法的数学原理：
- **逆序存储**让计算变得直观
- **逐位相加**配合**进位处理**是核心
- **虚拟头节点**简化了边界情况处理
- **时间复杂度最优**，无法再快了

掌握这个问题的解法，不仅有助于面试，更能加深对链表操作和算法设计的理解。