以下是对两数之和问题的详细解析，包括代码注释、知识点整理和面试准备：

## 代码分析与注释

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 使用哈希表存储数字和对应的索引
        // key: 数字的值, value: 数字在数组中的索引
        unordered_map<int, int> hash_map;
        
        // 遍历数组中的每个元素
        for(int i = 0; i < nums.size(); i++) {
            // 计算当前数字需要的补数（目标值减去当前数字）
            int complement = target - nums[i];
            
            // 检查补数是否已经在哈希表中
            // find()方法返回迭代器，如果没找到则返回end()
            if (hash_map.find(complement) != hash_map.end()) {
                // 找到解，返回两个数字的索引
                // hash_map[complement]是之前存储的补数的索引
                // i是当前数字的索引
                return {hash_map[complement], i};
            }
            
            // 将当前数字和索引存入哈希表，供后续查找使用
            // 注意：这里在检查之后才存入，避免使用同一个元素两次
            hash_map[nums[i]] = i;
        }
        
        // 如果没有找到解，返回空数组
        // 根据题目假设，这种情况不会发生
        return {};
    }
};
```

## 核心知识点整理

### 1. 算法思路
- **哈希表法**：利用哈希表的O(1)查找特性，将时间复杂度从暴力解的O(n²)降低到O(n)
- **一次遍历**：在遍历过程中同时构建哈希表和查找补数
- **避免重复使用**：先检查补数，再存入当前数字，确保不会使用同一个元素两次

### 2. 数据结构：`unordered_map`
```cpp
// 创建哈希表
unordered_map<int, int> hash_map;

// 常用操作：
hash_map[key] = value;      // 插入键值对
hash_map.find(key);         // 查找键，返回迭代器
hash_map.count(key);        // 统计键出现的次数
hash_map.erase(key);        // 删除键值对
```

### 3. 时间复杂度分析
- **时间复杂度**：O(n) - 只需遍历数组一次
- **空间复杂度**：O(n) - 最坏情况下需要存储n-1个元素

### 4. 关键技巧
- **补数思想**：将问题转化为"查找target - nums[i]"
- **延迟存储**：先查找再存储，避免自匹配
- **迭代器检查**：使用`find() != end()`判断元素是否存在

## 面试常见问题与回答

### Q1: 为什么选择哈希表而不是其他数据结构？
**回答**：哈希表提供了O(1)的平均查找时间复杂度，非常适合这种需要频繁查找的场景。相比数组的O(n)查找或二叉搜索树的O(log n)查找，哈希表在时间效率上最优。

### Q2: 如果数组中有重复元素会怎样？
**回答**：算法仍然有效。当遇到重复元素时，哈希表中会存储最后一次出现的索引。由于我们先查找补数再存入当前元素，即使有重复也不会影响结果，因为找到的是之前出现的不同索引的元素。

### Q3: 为什么不在循环开始时就存入所有元素？
**回答**：如果先构建完整的哈希表，可能会遇到元素自匹配的问题。比如`nums = [3, 2, 4], target = 6`，如果先存完所有元素，当检查3时会找到自己，返回错误结果`[0, 0]`。

### Q4: 如何处理多个解的情况？
**回答**：题目假设每种输入只会对应一个答案。如果需要处理多个解，可以修改算法返回所有可能的索引对，使用vector存储多个结果。

### Q5: 如果数组很大，这个算法还适用吗？
**回答**：适用。哈希表法的空间复杂度为O(n)，对于大规模数据仍然高效。如果内存受限，可以考虑先排序再使用双指针法，但那样会改变原始索引。

### Q6: 能否用`hash_map.count()`代替`hash_map.find()`？
**回答**：可以，但`find()`更优，因为它直接返回迭代器，而`count()`需要额外的计数操作。两种写法的对比：
```cpp
// 使用find()
if (hash_map.find(complement) != hash_map.end())

// 使用count()
if (hash_map.count(complement) > 0)
```

## 算法变体与扩展

### 变体1：返回数字而非索引
如果允许修改数组，可以先排序再使用双指针法：
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum == target) return {nums[left], nums[right]};
        else if (sum < target) left++;
        else right--;
    }
    return {};
}
```

### 变体2：三数之和问题
基于两数之和的思路可以扩展到三数之和问题，使用固定一个数+两数之和的方法。

## 总结

两数之和问题是算法面试中的经典题目，它考察了：
- 对哈希表的理解和应用
- 时间复杂度优化意识
- 边界情况处理能力
- 代码实现的细节把控

掌握这个问题的多种解法和相关知识点，对于应对算法面试具有重要意义。